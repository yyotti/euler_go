package main

import "fmt"
import "math/big"

// Consider all integer combinations of ab for 2 <= a <= 5 and 2 <= b <= 5:
//
//     2^2=4, 2^3=8, 2^4=16, 2^5=32
//     3^2=9, 3^3=27, 3^4=81, 3^5=243
//     4^2=16, 4^3=64, 4^4=256, 4^5=1024
//     5^2=25, 5^3=125, 5^4=625, 5^5=3125
//
// If they are then placed in numerical order, with any repeats removed, we
// get the following sequence of 15 distinct terms:
//
//     4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125
//
// How many distinct terms are in the sequence generated by ab for
// 2 <= a <= 100 and 2 <= b <= 100?

const maxA = 100
const maxB = 100

func main() {
	fmt.Printf("P029A: %d\n", p029A(maxA, maxB))
}

// 全パターンを出す
func p029A(maxA int, maxB int) int {
	if maxA < 2 || maxB < 2 {
		return 0
	}

	values := map[string]struct{}{}
	for a := 2; a <= maxA; a++ {
		for b := 2; b <= maxB; b++ {
			bigA := big.NewInt(int64(a))
			bigA.Exp(bigA, big.NewInt(int64(b)), nil)
			values[bigA.Text(10)] = struct{}{}
		}
	}

	return len(values)
}

// 実際には計算しないでやる
//
// 2 <= a <= 100, 2 <= b <= 100 において、a=2の場合は
//   2^2, 2^3, 2^4, ... , 2^100
// であるが、この計算の過程で
//   2^2 = (2^2)^1 = 4^1
//   2^4 = (2^2)^2 = 4^2
//   2^6 = (2^2)^3 = 4^3
// など、2のべき乗を底としたべき乗数もいくつか表れる。4のべき乗は
//   2^2,2^4,2^6,...,2^100 = 4^1,4^2,4^3,...,4^50
// である。これらは4^nを計算している際にかぶるので、4はn>50の場合のみがかぶら
// ない数としてカウントできる。
//
// また、
//   2^3 = (2^3)^1 = 8^1
//   2^6 = (2^3)^2 = 8^2
// でもあるので、8のべき乗についても
//   2^3,2^6,...,2^33
// を生成できる。
//
// さらに、4^n(n>50)の計算の過程で、
//   4^52 = (4^2)^26 = 16^26
//     ...
//   4^100 = (4^2)^50 = 16^50
// であり、16については
//   (2^4)^25 = 16^25
// のように2と4で50乗まではかぶる。
//
// NOTE: 何とかなるかと思ったけど
//   4^12=2^24=8^8
// のようなパターンを削除するいい方法が思い付かずに断念。
// 素因数分解して真面目にやるしかないか？
func p029B(maxA int, maxB int) int {
	if maxA < 0 || maxB < 0 {
		return 0
	}

	counts := make(map[int]int, maxA)
	cnt := 0
	for a := 2; a <= maxA; a++ {
		min, ok := counts[a]
		if !ok {
			cnt += maxB - 1
		} else {
			cnt += maxB - min
		}

		k := a * a
		i := 2
		for k <= maxA {
			c := maxB / i
			if c > 1 {
				counts[k] = c
			}
			k *= a
			i++
		}
	}
	if maxA == 50 {
		fmt.Println(counts)
	}

	return cnt
}
